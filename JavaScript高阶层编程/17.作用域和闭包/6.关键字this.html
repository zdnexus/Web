<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

<!--内联事件处理函数中的 this-->
<button onclick="alert(this.tagName.toLocaleUpperCase());">
    Show this
</button>
<!--如果 this 被包含在匿名函数中，则是window。-->
<button onclick="alert((function(){return this})());">
    Show in this
</button>
<!--如果 this 被包含在JS代码的匿名函数中，则是undefined。this的作用域不同。-->
<button onclick="alert(f1());">
    Show out this
</button>

<button id="btn" type="button">click</button>

</body>
<script>
    'use strict';

    // 全局上下文的 this
    // 在浏览器中，this 指代全局对象 window
    console.log(this === window); // true


    // 函数上下文的 this
    // 在「严格模式」下，禁止 this 关键字指向全局对象（在浏览器环境中也就是 window 对象），this 的值将维持 undefined 状态。
    function f1() {
        console.log(this === window); // false
        return this;
    }
    console.log(f1() === window); // false


    // 对象方法中的 this
    // 当我们执行 o.f() 时，方法 f() 中的 this 指代调用函数的那个对象，也就是对象 o，所以 this.name 也就是 o.name。
    var o = {
        name: 'stone',
        f2: function () {
            return this.name;
        }
    };
    console.log(o.f2()); // 'stone'


    // 对象方法中的 this
    var f3 = function () {
        return this.name;
    };
    var o2 = {name: 'stone'};
    o2.f = f3;
    console.log(o2.f()); // 'stone'
    //    console.log(f3()); // ERROR: name is not defined


    // eval() 方法中的 this
    // 全局上下文
    function f4() {
        console.log(eval('this') === window); // false
        return eval('this');
    }
    console.log(f4() === window); // false
    // 函数上下文
    var o3 = {
        name: 'stone',
        f5: function () {
            return eval('this.name');
        }
    };
    console.log(o3.f5()); // 'stone'


    // call() 和 apply() 方法中的 this
    function f6() {
        console.log(this.name);
    }
    var o4 = {};
    o4.name = 'nexus';
    o4.f = f6;
    o4.f(); // 'nexus'
    f6.apply(o4); // 'nexus'
    console.log(o4.f() === f6.apply(o4));// true

    // DOM 事件处理函数中的 this
    var btn = document.getElementById('btn');
    // 当函数使用 addEventListener，被用作事件处理函数时，它的 this 指向触发事件的元素。
    btn.addEventListener('click', function () {
        this.style.backgroundColor = '#A5D9F3';
    }, false);
    // 但在 IE 浏览器中，当函数使用 attachEvent ，被用作事件处理函数时，它的 this 却指向 window。
    if (btn.attachEvent) {
        btn.attachEvent('onclick', function () {
            console.log(this === window);  // true
        });
    }
</script>
</html>