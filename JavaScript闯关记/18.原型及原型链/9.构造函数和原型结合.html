<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
<script>
    // 构造函数用于定义实例属性，而原型用于定义方法和共享的属性。
    // 结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存

    // 构造函数添加实例属性
    function Person(name, age, job){
        if(name && age && job){
            this.name = name;
            this.age = age;
            this.job = job;
        }
        this.friends = ['Glx', 'Lis'];
    }
    // 原型用于定义方法和共享的属性
    Person.prototype = {
        constructor : Person,
        showMsg : function(){
            console.log('原型：我的名字叫' + this.name + '，今年' + this.age + '岁，工作是' + this.job);
        }
    };

    var person1 = new Person();
    var person2 = new Person();

    // 修改了 person1.friends（向其中添加一个新字符串），并不会影响到 person2.friends，因为它们分别引用了不同的数组。
    person1.friends.push('Pol');
    console.log(person1.friends);                       // [ 'Glx', 'Lis', 'Pol' ]
    console.log(person2.friends);                       // [ 'Glx', 'Lis' ]
    console.log(person1.friends === person2.friends);   // false
    console.log(person1.showMsg === person2.showMsg);   // true

    // 这种构造函数与原型混成的模式，是目前在 JavaScript 中使用最广泛、认同度最高的一种创建自定义类型的方法。
    // 可以说，这是用来定义引用类型的一种默认模式。
</script>
</html>