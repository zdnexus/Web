<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
<script>
    // 每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。

    // 利用原型让一个引用类型继承另一个引用类型的属性和方法。
    function GrandFather() {
        this.value = 'Glx';
    }
    GrandFather.prototype.getValue = function () {
        return this.value;
    };

    var grandFather = new GrandFather();
    console.log(GrandFather.prototype.constructor === GrandFather); // true
    console.log(grandFather.__proto__ === GrandFather.prototype);   // true
    console.log(grandFather.getValue());                            // 'Glx'

    // Father 继承 GrandFather。
    function Father() {
        this.value2 = 'Lis';
    }
    // 实现的本质是重写原型对象，Father.prototype 被重写，代之以一个新类型的实例。
    Father.prototype = new GrandFather();
    // 新添加原型函数
    Father.prototype.getValue2 = function () {
        return this.value2;
    };

    var father = new Father();
    console.log(father.getValue());     // 'Glx'
    console.log(father.getValue2());    // 'Lis'

    // Son 继承 Father。
    function Son() {
        this.value3 = 'Lop';
    }
    // 实现的本质是重写原型对象，Son.prototype 被重写，代之以一个新类型的实例。
    Son.prototype = new Father();
    // 新添加原型函数
    Son.prototype.getValue3 = function () {
        return this.value3;
    };

    var son = new Son();
    console.log(son.getValue());    // 'Glx'
    console.log(son.getValue2());   // 'Lis'
    console.log(son.getValue3());   // 'Lop'
    console.log(son.value);         // 'Glx'
    delete son.value;   // 删除无效
    console.log(son.value);         // 'Glx'
</script>
</html>